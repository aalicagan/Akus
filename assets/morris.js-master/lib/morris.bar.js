(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Morris.Bar = (function(_super) {
    __extends(Bar, _super);

    function Bar(options) {
      this.onHoverOut = __bind(this.onHoverOut, this);
      this.onHoverMove = __bind(this.onHoverMove, this);
      this.onGridClick = __bind(this.onGridClick, this);
      if (!(this instanceof Morris.Bar)) {
        return new Morris.Bar(options);
      }
      Bar.__super__.constructor.call(this, $.extend({}, options, {
        parseTime: false
      }));
    }

    Bar.prototype.init = function() {
      this.cumulative = this.options.stacked;
      if (this.options.hideHover !== 'always') {
        this.hover = new Morris.Hover({
          parent: this.el
        });
        this.on('hovermove', this.onHoverMove);
        this.on('hoverout', this.onHoverOut);
        return this.on('gridclick', this.onGridClick);
      }
    };

    Bar.prototype.defaults = {
      barSizeRatio: 0.75,
      barGap: 3,
      barColors: ['#0b62a4', '#7a92a3', '#4da74d', '#afd8f8', '#edc240', '#cb4b4b', '#9440ed'],
      barOpacity: 1.0,
      barHighlightOpacity: 1.0,
      highlightSpeed: 150,
      barRadius: [0, 0, 0, 0],
      xLabelMargin: 50,
      horizontal: false,
      shown: true,
      inBarValue: false,
      inBarValueTextColor: 'white',
      inBarValueMinTopMargin: 1,
      inBarValueRightMargin: 4
    };

    Bar.prototype.calc = function() {
      var _ref;
      this.calcBars();
      if (this.options.hideHover === false) {
        return (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(this.data.length - 1));
      }
    };

    Bar.prototype.calcBars = function() {
      var idx, row, y, _i, _len, _ref, _results;
      _ref = this.data;
      _results = [];
      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
        row = _ref[idx];
        row._x = this.xStart + this.xSize * (idx + 0.5) / this.data.length;
        _results.push(row._y = (function() {
          var _j, _len1, _ref1, _results1;
          _ref1 = row.y;
          _results1 = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            y = _ref1[_j];
            if (y != null) {
              _results1.push(this.transY(y));
            } else {
              _results1.push(null);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Bar.prototype.draw = function() {
      var _ref;
      if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'x') {
        this.drawXAxis();
      }
      return this.drawSeries();
    };

    Bar.prototype.drawXAxis = function() {
      var angle, basePos, i, label, labelBox, margin, maxSize, offset, prevAngleMargin, prevLabelMargin, row, size, startPos, textBox, _i, _ref, _results;
      if (!this.options.horizontal) {
        basePos = this.getXAxisLabelY();
      } else {
        basePos = this.getYAxisLabelX();
      }
      prevLabelMargin = null;
      prevAngleMargin = null;
      _results = [];
      for (i = _i = 0, _ref = this.data.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        row = this.data[this.data.length - 1 - i];
        if (!this.options.horizontal) {
          label = this.drawXAxisLabel(row._x, basePos, row.label);
        } else {
          label = this.drawYAxisLabel(basePos, row._x - 0.5 * this.options.gridTextSize, row.label);
        }
        if (!this.options.horizontal) {
          angle = this.options.xLabelAngle;
        } else {
          angle = 0;
        }
        textBox = label.getBBox();
        label.transform("r" + (-angle));
        labelBox = label.getBBox();
        label.transform("t0," + (labelBox.height / 2) + "...");
        if (angle !== 0) {
          offset = -0.5 * textBox.width * Math.cos(angle * Math.PI / 180.0);
          label.transform("t" + offset + ",0...");
        }
        if (!this.options.horizontal) {
          startPos = labelBox.x;
          size = labelBox.width;
          maxSize = this.el.width();
        } else {
          startPos = labelBox.y;
          size = labelBox.height;
          maxSize = this.el.height();
        }
        if (((prevLabelMargin == null) || prevLabelMargin >= startPos + size || (prevAngleMargin != null) && prevAngleMargin >= startPos) && startPos >= 0 && (startPos + size) < maxSize) {
          if (angle !== 0) {
            margin = 1.25 * this.options.gridTextSize / Math.sin(angle * Math.PI / 180.0);
            prevAngleMargin = startPos - margin;
          }
          if (!this.options.horizontal) {
            _results.push(prevLabelMargin = startPos - this.options.xLabelMargin);
          } else {
            _results.push(prevLabelMargin = startPos);
          }
        } else {
          _results.push(label.remove());
        }
      }
      return _results;
    };

    Bar.prototype.getXAxisLabelY = function() {
      return this.bottom + (this.options.xAxisLabelTopPadding || this.options.padding / 2);
    };

    Bar.prototype.drawSeries = function() {
      var barMiddle, barWidth, bottom, groupWidth, i, idx, lastTop, left, leftPadding, numBars, row, sidx, size, spaceLeft, top, ypos, zeroPos, _i, _ref;
      this.seriesBars = [];
      groupWidth = this.xSize / this.options.data.length;
      if (this.options.stacked) {
        numBars = 1;
      } else {
        numBars = 0;
        for (i = _i = 0, _ref = this.options.ykeys.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          if (this.hasToShow(i)) {
            numBars += 1;
          }
        }
      }
      barWidth = (groupWidth * this.options.barSizeRatio - this.options.barGap * (numBars - 1)) / numBars;
      if (this.options.barSize) {
        barWidth = Math.min(barWidth, this.options.barSize);
      }
      spaceLeft = groupWidth - barWidth * numBars - this.options.barGap * (numBars - 1);
      leftPadding = spaceLeft / 2;
      zeroPos = this.ymin <= 0 && this.ymax >= 0 ? this.transY(0) : null;
      this.bars = (function() {
        var _j, _len, _ref1, _results;
        _ref1 = this.data;
        _results = [];
        for (idx = _j = 0, _len = _ref1.length; _j < _len; idx = ++_j) {
          row = _ref1[idx];
          this.seriesBars[idx] = [];
          lastTop = 0;
          _results.push((function() {
            var _k, _len1, _ref2, _results1;
            _ref2 = row._y;
            _results1 = [];
            for (sidx = _k = 0, _len1 = _ref2.length; _k < _len1; sidx = ++_k) {
              ypos = _ref2[sidx];
              if (!this.hasToShow(sidx)) {
                continue;
              }
              if (ypos !== null) {
                if (zeroPos) {
                  top = Math.min(ypos, zeroPos);
                  bottom = Math.max(ypos, zeroPos);
                } else {
                  top = ypos;
                  bottom = this.bottom;
                }
                left = this.xStart + idx * groupWidth + leftPadding;
                if (!this.options.stacked) {
                  left += sidx * (barWidth + this.options.barGap);
                }
                size = bottom - top;
                if (this.options.verticalGridCondition && this.options.verticalGridCondition(row.x)) {
                  if (!this.options.horizontal) {
                    this.drawBar(this.xStart + idx * groupWidth, this.yEnd, groupWidth, this.ySize, this.options.verticalGridColor, this.options.verticalGridOpacity, this.options.barRadius);
                  } else {
                    this.drawBar(this.yStart, this.xStart + idx * groupWidth, this.ySize, groupWidth, this.options.verticalGridColor, this.options.verticalGridOpacity, this.options.barRadius);
                  }
                }
                if (this.options.stacked) {
                  top -= lastTop;
                }
                if (!this.options.horizontal) {
                  lastTop += size;
                  _results1.push(this.seriesBars[idx][sidx] = this.drawBar(left, top, barWidth, size, this.colorFor(row, sidx, 'bar'), this.options.barOpacity, this.options.barRadius));
                } else {
                  lastTop -= size;
                  this.seriesBars[idx][sidx] = this.drawBar(top, left, size, barWidth, this.colorFor(row, sidx, 'bar'), this.options.barOpacity, this.options.barRadius);
                  if (this.options.inBarValue && barWidth > this.options.gridTextSize + 2 * this.options.inBarValueMinTopMargin) {
                    barMiddle = left + 0.5 * barWidth;
                    _results1.push(this.raphael.text(bottom - this.options.inBarValueRightMargin, barMiddle, this.yLabelFormat(row.y[sidx], sidx)).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.inBarValueTextColor).attr('text-anchor', 'end'));
                  } else {
                    _results1.push(void 0);
                  }
                }
              } else {
                _results1.push(null);
              }
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }).call(this);
      this.flat_bars = $.map(this.bars, function(n) {
        return n;
      });
      this.flat_bars = $.grep(this.flat_bars, function(n) {
        return n != null;
      });
      return this.bar_els = $($.map(this.flat_bars, function(n) {
        return n[0];
      }));
    };

    Bar.prototype.hilight = function(index) {
      var i, y, _i, _j, _len, _len1, _ref, _ref1;
      if (this.seriesBars && this.seriesBars[this.prevHilight] && this.prevHilight !== null && this.prevHilight !== index) {
        _ref = this.seriesBars[this.prevHilight];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          y = _ref[i];
          if (y) {
            y.animate({
              'fill-opacity': this.options.barOpacity
            }, this.options.highlightSpeed);
          }
        }
      }
      if (this.seriesBars && this.seriesBars[index] && index !== null && this.prevHilight !== index) {
        _ref1 = this.seriesBars[index];
        for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
          y = _ref1[i];
          if (y) {
            y.animate({
              'fill-opacity': this.options.barHighlightOpacity
            }, this.options.highlightSpeed);
          }
        }
      }
      return this.prevHilight = index;
    };

    Bar.prototype.colorFor = function(row, sidx, type) {
      var r, s;
      if (typeof this.options.barColors === 'function') {
        r = {
          x: row.x,
          y: row.y[sidx],
          label: row.label,
          src: row.src
        };
        s = {
          index: sidx,
          key: this.options.ykeys[sidx],
          label: this.options.labels[sidx]
        };
        return this.options.barColors.call(this, r, s, type);
      } else {
        return this.options.barColors[sidx % this.options.barColors.length];
      }
    };

    Bar.prototype.hitTest = function(x, y) {
      var pos;
      if (this.data.length === 0) {
        return null;
      }
      if (!this.options.horizontal) {
        pos = x;
      } else {
        pos = y;
      }
      pos = Math.max(Math.min(pos, this.xEnd), this.xStart);
      return Math.min(this.data.length - 1, Math.floor((pos - this.xStart) / (this.xSize / this.data.length)));
    };

    Bar.prototype.onGridClick = function(x, y) {
      var bar_hit, index;
      index = this.hitTest(x, y);
      bar_hit = !!this.bar_els.filter(function() {
        return $(this).is(':hover');
      }).length;
      return this.fire('click', index, this.data[index].src, x, y, bar_hit);
    };

    Bar.prototype.onHoverMove = function(x, y) {
      var index, _ref;
      index = this.hitTest(x, y);
      this.hilight(index);
      if (index != null) {
        return (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(index));
      } else {
        return this.hover.hide();
      }
    };

    Bar.prototype.onHoverOut = function() {
      this.hilight(-1);
      if (this.options.hideHover !== false) {
        return this.hover.hide();
      }
    };

    Bar.prototype.hoverContentForRow = function(index) {
      var content, j, row, x, y, _i, _len, _ref;
      row = this.data[index];
      content = $("<div class='morris-hover-row-label'>").text(row.label);
      content = content.prop('outerHTML');
      _ref = row.y;
      for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {
        y = _ref[j];
        if (this.options.labels[j] === false) {
          continue;
        }
        content += "<div class='morris-hover-point' style='color: " + (this.colorFor(row, j, 'label')) + "'>\n  " + this.options.labels[j] + ":\n  " + (this.yLabelFormat(y, j)) + "\n</div>";
      }
      if (typeof this.options.hoverCallback === 'function') {
        content = this.options.hoverCallback(index, this.options, content, row.src);
      }
      if (!this.options.horizontal) {
        x = this.left + (index + 0.5) * this.width / this.data.length;
        return [content, x];
      } else {
        x = this.left + 0.5 * this.width;
        y = this.top + (index + 0.5) * this.height / this.data.length;
        return [content, x, y, true];
      }
    };

    Bar.prototype.drawBar = function(xPos, yPos, width, height, barColor, opacity, radiusArray) {
      var maxRadius, path;
      maxRadius = Math.max.apply(Math, radiusArray);
      if (maxRadius === 0 || maxRadius > height) {
        path = this.raphael.rect(xPos, yPos, width, height);
      } else {
        path = this.raphael.path(this.roundedRect(xPos, yPos, width, height, radiusArray));
      }
      return path.attr('fill', barColor).attr('fill-opacity', opacity).attr('stroke', 'none');
    };

    Bar.prototype.roundedRect = function(x, y, w, h, r) {
      if (r == null) {
        r = [0, 0, 0, 0];
      }
      return ["M", x, r[0] + y, "Q", x, y, x + r[0], y, "L", x + w - r[1], y, "Q", x + w, y, x + w, y + r[1], "L", x + w, y + h - r[2], "Q", x + w, y + h, x + w - r[2], y + h, "L", x + r[3], y + h, "Q", x, y + h, x, y + h - r[3], "Z"];
    };

    return Bar;

  })(Morris.Grid);

}).call(this);
